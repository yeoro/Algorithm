# **순열**
![permutation](https://t1.daumcdn.net/cfile/tistory/2656264355D3742516)
- 서로 다른 **N**개의 수 중에 **R**개를 **순서있게** 나열하는 것
- N과 R이 같을 경우 **N!** 과 같다.
- R이 **고정**되어있다면 **반복문**만으로 구현이 가능하다.
- 대부분 R이 **가변적**이므로 **재귀**를 이용하여 구현한다.
- 각 자리에서 **앞쪽**에 **선택된 변수를 배제**하고 가능한 모든 수를 선택하며 순열을 구현한다.
- 수가 선택되었는지 판단하기 위해 **Boolean** 배열 혹은 **비트마스킹**을 이용한다.
- 비트마스킹
>- int 배열로 처리 -> **32bit** 사용하므로 **공간 복잡도 측면에서 좋음**
>-  1 << a : 1비트를 오른쪽에서 a 위치에 올 수 있도록
>- n & a : 해당 a 자리 비트가 n비트열 사용 여부 확인 -> 방문 여부 확인 (v[i] == false)
>- n | a : n비트열에 a자리 비트를 1로 하여 합치기 -> 방문 체크 (v[i] = true)

# **중복순열**
![repetition](https://t1.daumcdn.net/cfile/tistory/23725F375621473815)
- 서로 다른 **N**개의 수 중에 **중복**하여 **R**개를 **순서있게** 나열하는 것
- **N^R** 로 표현이 가능하다.

# **Next Permutation**
![np](https://leetcode.com/media/original_images/31_Next_Permutation.gif)
- 현재 순열의 상태에서 **크기순(사전순)으로** 다음에 올 수 있는 순열
- 다음으로 큰 순열을 구하는 것이기 때문에 **중복 순열이 나오지 않는다**.
- 구현 (찾-찾-교-교)
> 1. **뒤쪽부터 탐색**하며 **꼭대기(i)** 찾기
> 2. 뒤쪽부터 오름차순으로 탐색하다가 **내림차순**이 되는 순간이 꼭대기이고, **꼭대기 왼쪽의 자리(i-1)** 가 **교환**할 자리이다.
> 3. **꼭대기**가 **가장 왼쪽(i==0)** 에 있는 경우는 **더 이상 만들 순열이 없다**는 뜻이다.
> 4. 맨 뒤쪽에서 부터 꼭대기(i)까지 수를 탐색하며 **(i-1) 보다 큰 값(j)을 찾아 교환**
> 5. **i 부터 맨 뒤**자리 까지의 수들은 **내림차순**으로 되어있기 때문에, **오름차순으로 교환(정렬)** 해주어야 한다.