# <img src="https://static.solved.ac/tier_small/9.svg" width=30> 11053: 가장 긴 증가하는 부분 수열 

### 문제 링크
> https://www.acmicpc.net/problem/11053

### 알고리즘 분류
>- 다이나믹 프로그래밍

### 풀이 시간
>- ⏱ 분

### 해결
> ![good](../../../Img/good.png)
>1. 최장 증가 부분 수열(LIS, Longest Increasing Subsequence)은 다음의 2가지 방법으로 구현이 가능하다.
>2. 2개의 for문 이용
>       * 시간 복잡도 - O(N^2)
>       1. 외부 반복문은 0부터 N-1까지 진행한다. 현재 숫자에서 가능한 수열 길이를 1로 초기화한다.
>       2. 내부 반복문은 0부터 i-1까지 진행한다. 현재 숫자보다 작은 숫자가 존재한다면 해당 숫자에서의 수열 길이와 현재 숫자의 수열 길이+1를 비교하여 더 큰 값을 선택한다.
>       3. dp 배열을 정렬한 후 맨 마지막 인덱스의 값을 출력한다.
>3. 이분 탐색 이용
>       * 시간 복잡도 - O(NlogN)
>       1. dp[0]의 값을 수열의 첫번 째 숫자로 초기화한다.
>       2. 1부터 N-1까지 반복문을 진행한다. dp 배열의 마지막 숫자 값이 nums 배열의 현재 숫자보다 작다면 바로 뒤에 넣는다. dp 배열의 인덱스 dpIdx를 1 증가한다.
>       3. dp 배열의 마지막 인덱스 값이 nums 배열의 현재 숫자보다 크다면 이분 탐색을 진행하여 들어갈 자리를 찾는다.  
>           - 초기 left는 0, right는 dp 배열의 마지막 숫자 인덱스이다. target은 dp 배열에 넣을 nums의 값이다.  
>           - left와 right의 값이 같아질 때까지 다음 과정을 진행한다.  
>                   - left와 right의 중앙 값을 구한다.  
>                   - 중앙 값이 target보다 작다면 left를 중앙 값 오른쪽으로 바꾸고, 크다면 right를 중앙 값으로 바꾼다.
>       4. 이분 탐색을 끝낸 후 dp[right]에 nums의 값을 넣는다.
>       5. dpIdx+1를 출력한다.
>3. (21.05.25 추가) Arrays 클래스의 binarySearch 메소드가 있었다..!!
>       1. 마지막 수보다 작은 수가 왔을 경우 들어갈 자리를 찾는데, 이 메소드를 사용한다면 이미 수열에 있는 숫자는 양수의 인덱스를 반환한다. 
>       2. 반대로 없는 숫자인 경우는 아래의 그림과 같이 들어갈 자리의 음수 인덱스를 다음과 같이 반환한다.  
>           - -(현재 자리를 찾는 수보다 작은 값들 중 가장 큰 값의 인덱스) - 1 
>       3. 따라서 idx의 값이 음수라면 이미 있는 숫자이므로 건너뛰고, 양수라면 자리를 찾아 넣는다.
>       - 이 메소드는 정렬된 배열에서만 사용이 가능한데, LIS 배열은 항상 정렬된 배열이므로 사용이 가능한 것 같다.
