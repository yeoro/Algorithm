# <img src="https://static.solved.ac/tier_small/12.svg" width=30> 1062: 가르침 

### 문제 링크
> https://www.acmicpc.net/problem/1062

### 알고리즘 분류
>- 백트래킹
>- 비트마스킹
>- 브루트포스 알고리즘
>- 문자열

### 풀이 시간
>- ⏱ 55분

### 해결
> ![bad](../../../Img/bad.png)  
>1. 시간 초과가 떴길래 다음과 같은 방법들로 해결하려고 했다.
>       1. 알파벳 조합을 담는 공간을 리스트에서 배열로 바꿈 (확실히 시간은 많이 줄일 수 있었다.)
>       2. K가 5보다 작을 때 바로 0 출력하고 종료
>       3. 길이가 8인 단어는 스킵
>2. 위의 방법은 다 소용이 없었다. 결과적으로 주어진 단어들에서 "anta", "tica"를 지우는 replace 메소드에서 시간이 오래 걸렸던 것 같다.
>  
> ![good](../../../Img/good.png)
>1. 남극 기본 단어인 (a, c, i, n, t)를 제외한 나머지 21개의 알파벳 중에서 K-5개를 골라 알파벳 조합을 구하고, 해당 조합으로 가능한 단어 중 최대 개수를 구하는 문제였다.
>2. 주어진 단어들을 저장할 ArrayList를 만들고, 모든 단어에서 replace 메소드를 이용하여 "anta", "tica"를 제거한 후 저장한다.
>3. 알파벳 조합을 저장할 ArrayList를 만들고, 5개의 남극 단어를 미리 넣어준다.
>4. 나머지 21개의 알파벳을 저장한 배열과 크기가 21인 방문체크 배열을 사용해 N-K개의 알파벳을 고른다. 
>5. 입력 단어 중에서 못 읽는 알파벳이 있다면 다음 단어로 넘어가고, 그렇지 않다면 cnt 변수를 1 증가한다. 현재 조합에서의 cnt 값과 현재 최댓값을 비교한 후 최댓값을 갱신해준다.
