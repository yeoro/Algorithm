# <img src="https://static.solved.ac/tier_small/8.svg" width=30> 2579: 계단 오르기 

### 문제 링크
> https://www.acmicpc.net/problem/2579

### 알고리즘 분류
>- 다이나믹 프로그래밍

### 풀이 시간
>- ⏱ 2시간+

### 해결
> ![bad](../../../Img/bad.png)  
>1. 재귀로 접근했으나 3번 연속 밟는 경우를 처리하지 못해 오답이 나왔다.
>  
> ![good](../../../Img/good.png)
>- 주어진 조건 때문에 생각하기 어려웠다.. 마지막 계단을 무조건 밟아야 하므로 마지막 계단의 입장에서 이전을 생각해봐야하는 문제였다.
>1. 2차원 dp 배열을 선언한다. 배열의 열은 크기를 2로 하여 1이면 N-1에서 온 경우, 0이면 N-2에서 온 경우의 점수를 저장한다.
>2. N번째 계단을 반드시 밟는 경우는 2가지이다.
>       - N-1 계단에서 오는 경우
>       - N-2 계단에서 오는 경우
>3. N-1 계단에서 오는 경우는 연속된 세 계단을 밟지 못한다는 조건에 따라 N-2를 밟지 않고 N-3에서 온 경우이다. 따라서 다음과 같은 점화식을 세울 수 있다.
>       - dp[n][1] = dp[n-1][0] + score[n];
>4. N-2 계단에서 오는 경우는 N-1 계단을 밟지 않고 N-2 계단에서 온 경우이므로 N-2가 N-3에서 왔는지 N-4에서 왔는지는 상관없다. 따라서 다음과 같은 점화식을 세울 수 있다.
>       - dp[n][0] = Math.max(dp[n-2][0], dp[n-2][1]) + score[n];
>5. dp 배열을 채웠다면 dp[n][0]과 dp[n][1] 중 큰 값을 출력한다.
