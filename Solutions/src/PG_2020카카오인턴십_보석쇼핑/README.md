# <img src="https://programmers.co.kr/assets/bi-symbol-light-49a242793b7a8b540cfc3489b918e3bb2a6724f1641572c14c575265d7aeea38.png" width=30>  2020 카카오 인턴십 - 보석 쇼핑

### 문제 링크
> https://programmers.co.kr/learn/courses/30/lessons/67258

### 알고리즘 분류
>- 두 포인터

### 풀이 시간
>- ⏱ 1시간 30분

### 해결
>1. Map과 Set, Queue를 이용하여 단순하게 풀다가 오답이 많이 나서 다른 소스를 참조하여 풀었다.
>2. 두 포인터 혹은 슬라이딩 윈도우 알고리즘을 이용해야했다. 처음 보는 알고리즘이어서 우선 참조하여 풀고 같은 알고리즘 문제를 풀어보기로 했다.
>3. 답을 구하는 과정을 다음과 같다.  
>       1. 보석 배열의 값들을 HashSet에 넣어준다. Set은 중복을 허용하지 않기 때문에 보석의 갯수 및 종류 정보를 파악하기 위해 Set을 이용했다.  
>       2. 보석 배열의 값들을 HashMap에 넣어준다. Map에 없는 보석은 보석 이름과 0을 넣고, 이미 존재한다면 현재 넣은 갯수에 1을 증가하여 넣어준다. Map의 getOrDefault 메소드를 이용하면 깔끔하게 한 줄로 해결할 수 있다는점~
>       3. 큐에 보석 이름을 넣어준다. 이제 여기서 슬라이딩 윈도우 알고리즘의 로직이다. 
>       4. 큐의 맨 앞에 있는 보석을 Map에 2개 이상 넣어준 경우, 최소 구간을 구해야하기 때문에 가장 마지막에 넣어준 보석이 아닌 먼저 넣어준 보석을 빼준다.
>       5. 보석을 빼줬으니 Map에서도 보석의 갯수를 1 줄여준다. 구간의 시작 번호는 1 증가시켜준다.
>       6. while 문에서 위의 과정을 반복하다가, Map에 1개 넣어준 보석이 맨 앞에 있는 경우 while 문을 종료한다.
>       7. Map과 Set의 크기가 같다면 Map에 모든 보석이 1개 이상 존재하는 것으로 생각한다. 또한, 현재 큐의 크기가 곧 구간의 길이와 같으므로 구간의 마지막 번호의 값은 큐의 크기로 하고 시작 번호 또한 이전 과정에서 정해진 시작 번호로 바꿔준다.
>       8. 보석 배열 탐색이 끝난 후, 구간의 시작 번호는 배열의 인덱스이므로 1을 증가해주고 끝 번호에는 시작 번호를 더해준다.
