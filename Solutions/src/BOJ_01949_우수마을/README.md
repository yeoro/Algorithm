# <img src="https://static.solved.ac/tier_small/15.svg" width=30> 1949: 우수 마을 

### 문제 링크
> https://www.acmicpc.net/problem/1949

### 알고리즘 분류
>- 다이나믹 프로그래밍
>- 트리
>- 트리에서의 다이나믹 프로그래밍

### 풀이 시간
>- ⏱ 분

### 해결
> ![good](../../../Img/good.png)
>- 아이디어가 생각나지 않아 참고하여 풀었다..  
> 임의의 정점을 루트 노드로 정하고, top-down 으로 말단 노드까지 내려간 후 dp 배열을 갱신하면서 루트 노드까지 다시 올라오는 방식으로 구현해야 했다. 어렵다.
>1. (N x 2) 크기의 dp 배열을 선언한다. 0열은 우수 마을로 선택하지 않은 경우, 1열은 우수 마을로 선택한 경우이다.
>2. 루트 노드로 임의의 정점을 선택한다. 나는 1번 정점을 루트 노드로 정했고, 부모 정점을 인자로 같이 넣어준다. 부모 정점의 초기값은 0으로 했다.
>3. 연결된 정점 중에 부모 정점이 아닌 정점이면 재귀 호출을 한다. 이 과정을 통해 말단 정점까지 내려간다.
>4. 말단 정점에서는 연결된 정점이 없기 때문에 자기 자신을 우수 마을로 선택한 후 dp 배열을 갱신한다
>       - dp[node][1] = population[node]
>5. 말단 정점 까지 내려갔다면 다시 루트 정점까지 올라가면서 dp 배열을 갱신한다. 점화식은 다음과 같다.
>       - dp[node][0] += Math.max(dp[child][0], dp[child][1])
>       - dp[node][1] += dp[child][0]
>6. Math.max(dp[1][0], dp[1][1]) 를 출력한다.